
            +---------------------------+
            |          CS 140           |
            | PROJECT 3: VIRTUAL MEMORY |
            |      DESIGN DOCUMENT      |
            +---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

김동욱 (freezing16@unist.ac.kr)
이강준 (suri7897@unist.ac.kr)

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

            PAGE TABLE MANAGEMENT
            =====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

in vm/page.h ...

enum vm_type {
    VM_BIN, // loaded from the executable (binary)
    VM_FILE, // loaded from some file mapping (file)
    VM_ANON // anonymous (stack/heap/BSS), lives in swap after eviction
};

vm_type illustrate the type of spt_entry.

struct spt_entry {
    enum vm_type type; // type of the page this entry represents
    void* vpage; // corresponding virtual page address.
    bool is_loaded; // true if page is in memory
    bool writable; // true if it is writable.
    bool pinned; // true if the page must not be evicted (ex. During I/O)

    size_t swap_index; // index in the swap slot if the page is swapped.
    
    // below here, these are used for file-backed pages.
    struct file* file; // loaded file for this spt_entry
    size_t f_offset; // file offset in file.
    size_t read_bytes; // how many bytes are read in file.
    size_t zero_bytes; // number of bytes to be zeroed after reading from file
    //
    struct hash_elem elem; // spt_entry is member of hash. element structure in hash.
    struct list_elem mmap_elem; // for mmap list element.
};

spt_entry is supplementary table entry, and member of hash, spt(supplementary table).

in vm/frame.h ..

struct frame {
    void* kpage; // kernal page (physical page) of this frame
    struct spt_entry* spte; // corresponding spt_entry of this frame.
    struct thread* owner; // owner thread
    struct list_elem elem; // elem for frame_table
};

structure frame is the element of frame_table.

In vm/frame.c

static struct list frame_table; // frame_table : list of frame.
static struct lock frame_lock; // lock for frame : prevent multiple thread to modify frame at same time.
static struct list_elem* clock_hand; // position for the clock (second-chance) algorithm / element of frame_table.

In threads/thread.h

struct thread{
...
#endif

    /* Owned by thread.c. */
    unsigned magic; /* Detects stack overflow. */
    
    struct hash spt; <- hash that deals spt_entry. spt_entry is stored in this hash, spt.
...
} 

---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for accessing the data
>> stored in the SPT about a given page.

To find specific spt_entry in spt, we made function struct spt_entry* find_spte(void* vaddr);.
From the virtual address of corresponding spt_entry, we can find spt_entry for that vaddr.

struct spt_entry* find_spte(void* vaddr)
{
    struct spt_entry spt;
    struct hash_elem* e;
    struct thread* t = thread_current();

    spt.vpage = pg_round_down(vaddr);
    e = hash_find(&t->spt, &spt.elem);

    if (e == NULL)
        return NULL;
    return hash_entry(e, struct spt_entry, elem);
}

First, by pg_round_down, we can find page_base for corresponding vaddr. Then, by hash_find, we can find exact element of hash member, spt_entry.
Then, by hash_entry, we can find exact spt_entry.

>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?

In our implementation, we avoid coordinating accessed and dirty bits between kernel 
and user virtual addresses by tracking them only through the user mapping. 
Each frame is associated with a user virtual address (vpage) in the supplemental page table, 
and we use pagedir_is_accessed() and pagedir_is_dirty() on this address during eviction.
Although the kernel accesses the frame via its kernel virtual address (kpage), 
the accessed/dirty bits are still managed based on the page table entry mapped to the user virtual address. 
Therefore, we only query and clear these bits using the user address, which avoids complications due to aliasing.

---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?

As we described in the A1, we bring lock frame_lock to prevent from multi user threads accessing at same time.
This lock is used when one thread access frame_table.
For example, in the frame_get_page, function starts with lock_acquire(&frame_lock);.
The lock is necessary because frame_get_page() modifies shared state by evicting frames, allocating pages, and updating the frame_table. 
Without frame_lock, concurrent access could lead to data races and inconsistencies.

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?

We chose a hash table over a list for the supplemental page table to enable faster lookups. 
Since each page fault requires finding the corresponding spt_entry by virtual address, using a list would result in linear-time search, which is inefficient. 
A hash table allows constant-time average lookup, making page fault handling much more efficient and scalable.

               PAGING TO AND FROM DISK
               =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

In vm/swap.c ....

static struct block* swap_block; // the block used at swap space for paging out anonymous pages.
static struct bitmap* swap_map; // 0 indicates the block is free, and 1 is occupied.
static struct lock swap_lock; // similar as frame_lock, it is for swapping.

in spt_entry,  size_t swap_index; // index in the swap slot if the page is swapped.

-> Using swap_index and swap_bitmap, we can link each evicted page in the SPT to its location on the swap disk.

---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

For choosing a frame to evict, we used second-clock algorithm. 

In vm/frame.c ...

static struct frame* select_victim(void)
{
    while (true) {
        if (clock_hand == NULL || clock_hand == list_end(&frame_table))
            clock_hand = list_begin(&frame_table);

        struct frame* f = list_entry(clock_hand, struct frame, elem);
        struct thread* t = f->owner;

        bool is_upage_acceessed = pagedir_is_accessed(t->pagedir, f->spte->vpage);
        if (is_upage_acceessed || f->spte->pinned) {
            /* Second chance */
            pagedir_set_accessed(t->pagedir, f->spte->vpage, false);
        } else {
            /* Found the victim */
            return f;
        }

        clock_hand = list_next(clock_hand);
    }
}

In here, for all frame, we check whether it is accessed by using pagedir_is_accessed() function.
When pagedir_is_accessed is true, then make access bit as false, giving second chance to that frame.
If pagedir_is_accessed is False, then take this frame as victim.
Also, frames marked as `pinned` are skipped during victim selection to prevent evicting in-use pages.

>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?

When evicting a frame from memory, we call functions like pagedir_clear_page, palloc_free_page, and free_frame. 
Of course, before calling pagedir_clear_page, we check whether the page is dirty using pagedir_is_dirty to determine whether to write it back to disk.
These functions remove the page mapping from the page table, free the physical memory, and clean up the frame metadata.
Also, evicted frame is reused and new process can be assigned used frame after eviction.
Additionally, we must update the supplemental page table (SPT) of the process that previously owned the frame to reflect that the page is no longer loaded in memory.
For example, is_loaded should be changed to false, and when swapping is needed, swap_index should be modified.

>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

In our implementation, we allow stack growth when a page fault occurs at an unmapped address that is in user space, not NULL, 
within 32 bytes below the stack pointer, and within 8 MB of PHYS_BASE. 
If so, we allocate a frame, create a VM_ANON spt_entry, map the page, and update the supplemental page table. 
This ensures only valid stack operations cause stack growth.


---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

For frame_lock, we answered in A4. There is additional lock for swapping, swap_lock.
We use a global swap_lock to synchronize access to the swap system, including the swap_map bitmap and the swap_block device. 
Functions like swap_out, swap_in, and swap_free acquire this lock during their execution to ensure exclusive access 
and prevent race conditions when multiple threads attempt to read or write to swap at the same time.

To prevent deadlock, our design ensures that swap_lock is only held briefly and is never acquired together with other locks like frame_lock. 
We avoid nested locking and maintain a consistent locking order. This eliminates circular wait, which is one of the necessary conditions for deadlock. 
By keeping locking simple and isolated, we ensure that the swap mechanism remains thread-safe and deadlock-free.

>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

We use frame_lock to avoid race conditions between processes like P and Q. 
By acquiring frame_lock in every function that modifies the frame_table, we ensure that only one thread can access or evict a frame at a time. 
This prevents simultaneous modification or access to the same frame by multiple processes, which could otherwise lead to inconsistencies or data corruption. 
As a result, we maintain synchronization between frame eviction and allocation, avoiding race conditions.

>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

To prevent interference during page loading, we use both the global frame_lock and a pinned flag in each frame. 
When process P handles a page fault and begins loading a page from the file system or swap, 
it sets frame->pinned = true to temporarily protect the frame from eviction. 
While the frame is pinned, any page replacement algorithm will skip it. 
The page remains non-evictable until it is fully loaded, mapped with pagedir_set_page(), and marked as is_loaded = true in the supplemental page table. 
Only after this is pinned cleared. This mechanism ensures that no other process, like Q, can evict or use the frame 
while it is still being filled with data, preventing race conditions during loading.


>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

During system calls, we rely on page faults to load pages from disk if they are not present in memory. 
We do not lock frames ahead of time. Instead, before accessing any user-provided buffer, we call validate_buffer(), which checks each page in the buffer range.

void validate_buffer(void* buffer, unsigned size, void* esp, bool to_write)
{
    void* ptr;
    for (ptr = pg_round_down(buffer); ptr < buffer + size; ptr += PGSIZE) {
        struct spt_entry* spte = check_address(ptr, esp); // check_address returns spt_entry coressponding ptr.
        if (spte == NULL || !(spte->writable))
            exit(-1);
    }
}

Here, we check whether spt_entry is available for that buffer. 
If the supplemental page table entry does not exist (spte == NULL) or the page is not writable when a write is intended, we terminate the process using exit(-1). 
This prevents the kernel from accessing invalid or unauthorized memory during system calls. 
By checking each page within the buffer range, we ensure that all memory accesses are safe and that missing pages will be loaded via page faults when necessary.
Moreover, if a page is not loaded, a page fault brings it in from disk. 
To prevent eviction while the kernel accesses user memory during the system call, the corresponding frame is temporarily marked as pinned. 
It is unpinned once the system call finishes, ensuring safe and stable access during kernel use.

---- RATIONALE ----

>> B9: A single lock for the whole VM system would make
>> synchronization easy, but limit parallelism.  On the other hand,
>> using many locks complicates synchronization and raises the
>> possibility for deadlock but allows for high parallelism.  Explain
>> where your design falls along this continuum and why you chose to
>> design it this way.

In our implementation, we use two main locks for virtual memory: frame_lock for managing the frame table and swap_lock for accessing the swap space. 
With file_lock from Project 2, we have three locks in total.

Using more locks can increase parallelism, but also makes the system harder to manage and more likely to cause deadlocks. 
We chose to keep things simple. Each lock controls a separate part of the system, and they rarely overlap. 
For example, frame_lock and swap_lock are rarely held at the same time.

This design avoids most deadlock risks while still allowing some parallelism. 
We think adding more locks would make the code more complex and error-prone without giving much benefit in our case.


             MEMORY MAPPED FILES
             ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

In vm/page.h ...

struct mmap_file {
    int mapid; // Unique identifier for this memory-mapped file
    struct file* file; // File that is memory-mapped
    struct list_elem elem; // Element in the mmap_list in thread
    struct list spte_list; // list of supplemental page table entries mapped to this file
};

struct spt_entry {
...

struct list_elem mmap_elem; // list element of spte_list
};


In threads/thread.h ...

struct thread{
... 
    struct hash spt;
    
    // newly added below
    
    struct list mmap_list; // list of mmap_file in thread
    int next_mapid; // next available mapid to assign for mmap()
};

---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

Memory-mapped files are managed using mmap_file and spt_entry structures. 
When mmap() is called, we create a mmap_file and insert spt_entrys of type VM_FILE into the supplemental page table (SPT) for each page in the file.
On a page fault, the kernel finds the spt_entry, reads the required bytes from the file into a newly allocated frame, and maps it into memory. 
These pages are loaded lazily, only when accessed. 
For VM_FILE pages, if the page is dirty, it is written back to the file. 
For VM_ANON (swap) pages, the contents are written to the swap disk using swap_out(), and a swap_index is recorded.
This way, file-backed and swap-backed pages are handled differently for both page faults and eviction.

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

In mmap function,

int mmap(int fd, void* addr){
...
    if (find_spte(addr))
        return -1;
...
}

Here, we check whether spt_entry for that addr is present. If there is already allocated spt_entry for that addr, then we exit.
This can prevent new file mapping to overlap any existing segment.


---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

In our implementation, we share most of the code between memory-mapped files and executable-backed pages. 
Both types use the same supplemental page table structure and are loaded lazily on page faults. 
The main difference is in handling eviction: mmap pages are written back to the original file 
using file_write_at() if they are dirty, while executable pages are never written back. 
By treating both as VM_FILE types, we minimize code duplication and only add extra logic for write-back in the mmap case.


               SURVEY QUESTIONS
               ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?


==== Peer Evaluation ====

+----------------------------+---------------------------------+

|            Name            |          Contribution           |

+----------------------------+---------------------------------+

| 김동욱                     | 60% Implemented draft of supplementary page table, swapping, mmap, and debugging whole code.

+----------------------------+---------------------------------+

| 이강준                     | 40% Implemented draft of frame_table, eviction, debugging whole code.

+----------------------------+---------------------------------+
