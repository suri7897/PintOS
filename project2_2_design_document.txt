             +--------------------------+
             |          CS 140          |
             | PROJECT 2: USER PROGRAMS |
             |     DESIGN DOCUMENT      |
             +--------------------------+
           
---- GROUP ----

>> Fill in the names and email addresses of your group members.

김동욱 (freezing16@unist.ac.kr)
이강준 (suri7897@unist.ac.kr)

--- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

               ARGUMENT PASSING
               ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.
Nothing for argument passing.

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?
I implemented argument parsing using strtok_r() to tokenize the command line. 
After loading the executable, I pushed each argument onto the stack in reverse order, 
saving the pointers in an array. I then pushed the pointers themselves to form argv[], 
followed by argv, argc, and a fake return address (0). I ensured 16-byte alignment of 
the stack before pushing argv by adjusting the stack pointer. To avoid stack overflow, 
I checked the size of arguments and total memory used, returning an error if it exceeded one page.

---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?
strtok_r() is thread-safe because it maintains parsing state in a user-supplied variable. 
strtok() uses static storage, which is not safe in a multithreaded kernel like Pintos.

>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.
1. The kernel focus only on executing binaries, keeping it smaller and more secure
2. The shell supports features like piping, redirection, and scripting, which require 
more complex parsing than the kernel should manage.


// Above is for Project 2-1

                 SYSTEM CALLS
                 ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

in /thread.h/..

struct thread
{
...
#ifdef USERPROG (this means below is executed if thread is user thread)
    /* Owned by userprog/process.c. */
    uint32_t *pagedir;                  /* Page directory. */
    int exit_status;   // newly added  /  stores exit status for exit call.
    struct file* fdt[128]; // newly added / thread stores fd_table for file I/O.

   // project 2-2 //

    struct list child_list; 
    struct list_elem child_elem;
    struct semaphore wait_sema;
    struct semaphore exit_sema;
    bool is_waited;

    bool load_success; //! load success
    struct semaphore load_sema; //! sema for load success

    struct file* running_file; //! current running_file for denial of writing.


#endif
...
}

exit status is member of user_thread for saving exit_status.
fdt[128] is fd_table for saving 128 file descriptors in user_thread.

// project 2-2

child_list is new list for child lists. if child is created, then child's elem is added to the child_list.
child_elem is element of thread used for child_list.
wait_sema & exit_sema are the semaphore.
wait_sema is semaphore for parent which is waiting child's exit.
exit_sema is semaphore for child which is waiting for parent's access of exit status.
-> then, child can terminate.

in /syscall.c

struct lock file_lock; // lock for file system.

file_lock can make two or more threads unable to access file system simultaneously.

in /process.c

extern struct lock file_lock; //! exatly same with file_lock in syscall.c


>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?

In PintOS, file descriptors (FDs) are stored in the fd_table, which is a member of the user_thread structure.
Each process (user thread) has its own fd_table, so file descriptors are unique within a process, not across the entire OS.
When a file is opened, the system assigns the lowest available FD number in the table, so file descriptor maybe not unique.
However, only standard input (stdin) and standard output (stdout) can have unique fd in PintOS,
since by default, file descriptor 0 is reserved for stdin and file descriptor 1 for stdout.
(Unlike in full UNIX systems, standard error (stderr, fd 2) is not predefined in PintOS.)

---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.

1) read

if fd == 0, then input_getc is used to read the character from keyboard.
then, return the number of characters get from input_getc().

Consider 2<=fd<64.

First, check whether file is NULL or not. if NULL, then call exit.
if not, then read the file using file_read function in filesys.c.
then, return the return value of file_read.

2) write

if fd == 1, then write the contents in buffer to console, using putbuf().
then, return the size of contents that was written in console.

Consider 2<=fd<64.

First, check whether file is NULL or not. if NULL, then call exit.
if not, then write the file using file_write function in filesys.c.
then, return the return value of file_write.

* In both cases, the file_lock is applied for access of file system. *

>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?

For full page (4096 bytes), least = 1, max = 4096.
For 1, there could be case that all data is in the same page. (Not exceeding page boundary)
For 4096, there could be the case that all data is in different page, so 4096 page inspectation is needed.

For 2 bytes,  least = 1, max = 2.
For 1, same as full page, all data is in same page, so 1 page inspectation is needed.
For 2, there could be case that 2 byte of data is in different pages. 

For improvements :  instead of call pagedir_get_page() for every bit, call pagedir_get_page() only when page is changed. In this case, although possible maximum calls of pagedir_get_page() can be same, but in ordinary, pagedir_get_page() is called fewer times.


>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

For project 2-1, we implemented process_wait function as

int process_wait(tid_t child_tid UNUSED)
{
    timer_msleep (3000); //! for debugging
    return -1;
}

This function was used to artificially delay the parent process, allowing the child process enough time to execute and terminate.
Without this delay, the parent process would return immediately, which may cause the child process to be terminated before it has a chance to run properly.

However, this is not a correct implementation of process_wait, since it simply waits for a fixed duration regardless of whether the child has actually exited.
Therefore, this placeholder implementation must be replaced in Project 2-2 with a proper mechanism that waits for a specific child process to exit and returns its exit status. 
This is essential for the correct behavior of fork, exec, and related process control operations.

// Project 2-2

In Project 2-2, wait in syscall.c is not different from project2-1, just calling process_wait(pid);.
But, process_wait in process.c is different. 
By adding bool is_waited / sema wait_sema / sema exit_sema / child_list / child_elem, 
process can wait until child process terminates.

First, check whether there is child process having child pid, by using struct thread* get_child().
get_child returns child process's thread having same pid given as argument.
At the same time, check whether if there is another parent process waiting that child process.
if two conditions are not met, then return -1.

If met, make child->is_waited to true, indicating there is parent process that is waiting child.
And, down the child's wait_sema, resulting parent process to wait until child to exit.
(in process_exit, wait_sema is released, and exit_sema is downed.)
After, parent process get exit status of child, remove the child thread's element in child_list, and release the exit_sema, allowing child thread to terminate.

>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.

For address handling, we implemented is_valid_addr() function to validate the address given.
In this function, it checks whether address is in the user_space, and corresponding page is valid.
So, we used is_valid_addr() function for each system_call, so can keep our codes clean.
Also, in is_valid_addr(), we called exit(-1) if address is invalid. exit(-1) calls thread_exit, and thread_exit calls process_exit. process_exit then destroy current process's page directory. During destruction, these allocated resources are freed.

---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

In process_execute(), there is sema_down(&child->load_sema); and then check if child has completed loading successfully.
In start_process(), there is thread_current()->load_success = success; and sema_up(&thread_current()->load_sema);
In this process, status of load_success is stored and passed back to the thread that calls "exec".
Thus, the exec() system call blocks until the child has completed load(), and returns -1 if it failed



>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

1) P calls wait(C) before C exits
In process_wait, P calls sema_down(&child->wait_sema) to wait for the C to exit. This blocks P until C signals completion.
In process_exit, C calls sema_up(&cur->wait_sema) to signal that it has finished execution, allowing P to proceed.
After signaling, C calls sema_down(&cur->exit_sema) to wait until P has retrieved C’s exit status. 
P signals this by calling sema_up(&child->exit_sema) in process_wait after accessing the exit status.
Thus, P waits for C to exit before proceeding and C does not free its resources until P has safely retrieved the exit status, 
avoiding race conditions where P might access freed memory.

2) P calls wait(C) after C exits
If C has already exited, C will have called sema_up(&cur->wait_sema) in process_exit before terminating.
When P calls process_wait and executes sema_down(&child->wait_sema), the semaphore’s count is already positive, 
so P proceeds immediately without blocking.
P retrieves C’s exit_status and calls sema_up(&child->exit_sema). 
Since C is waiting on sema_down(&cur->exit_sema) in process_exit, this allows C to complete its cleanup.
The semaphore mechanism ensures no race condition, as C does not free its resources until P signals via exit_sema.

3) P terminates without waiting before C exits
When P exits, it calls sema_up(&C->exit_sema).
When C later exits and calls sema_down(&cur->exit_sema) in process_exit, the semaphore count is positive, 
so C proceeds without blocking. This prevents C from hanging and ensures proper cleanup.
P’s exit does not interfere with C’s execution, and C can exit cleanly later without blocking on exit_sema.

4) P terminates without waiting after C exits
If C has already exited, it will have signaled sema_up(&cur->wait_sema) and be blocked on sema_down(&cur->exit_sema), 
waiting for P to signal exit_sema.
In process_exit, P closes its files, destroys its page directory, and frees its memory.
C completes its cleanup after P’s exit, avoiding resource leaks.




---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

Since the pointers passed into kernel by syscall can point to the invalid memory, so we choose to implement function is_valid_addr().
In this function, first check whether it is user address, since system call is implemented in user_level, and check whether the corresponding page is mapped to page_table.
This could be helpful for protecting kernel from user level task, since it checks whether address is in kernel or user space at first, and can prevent from approaching invalid address. 

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

We implemented the file descriptor table(fdt[64]) as member of struct thread, with shape of fixed-size array. This array style fdt could be seen as the simplest style of the fd_table, and each file is naturally seperated by the shape of array.
Also, we can handle files more in simple way because only we need is to access thread's member.
But, in my way, fixed file descriptor table can be the disadvantage, since in most tests 64 file descriptors are not used, so wasting memories.
Also, in opposite situation, we cannot open more files due to limited fdt.
Additionally, when many threads are needed, fdt size could be limitation for max number of threads in one time.
In last, since it is array, we should find files by indexing all files, leading to inefficient computation of file system.

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

We persisted identity mapping to tid_t and pid_t. 

               SURVEY QUESTIONS
               ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?


==== Peer Evaluation ====

+----------------------------+---------------------------------+

|            Name            |          Contribution           |

+----------------------------+---------------------------------+

| 김동욱                      | 50%, Main contribution on wait, exit (semaphore). Debugging entire project.

+----------------------------+---------------------------------+

| 이강준                      | 50%, Main contribution on System_call, file_lock, Denying write to Executables. Debugging entire project.

+----------------------------+---------------------------------+
