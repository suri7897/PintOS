             +--------------------------+
             |          CS 140          |
             | PROJECT 2: USER PROGRAMS |
             |     DESIGN DOCUMENT      |
             +--------------------------+
           
---- GROUP ----

>> Fill in the names and email addresses of your group members.

김동욱 (freezing16@unist.ac.kr)
이강준 (suri7897@unist.ac.kr)

--- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

               ARGUMENT PASSING
               ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.
Nothing for argument passing.

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?
I implemented argument parsing using strtok_r() to tokenize the command line. 
After loading the executable, I pushed each argument onto the stack in reverse order, 
saving the pointers in an array. I then pushed the pointers themselves to form argv[], 
followed by argv, argc, and a fake return address (0). I ensured 16-byte alignment of 
the stack before pushing argv by adjusting the stack pointer. To avoid stack overflow, 
I checked the size of arguments and total memory used, returning an error if it exceeded one page.

---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?
strtok_r() is thread-safe because it maintains parsing state in a user-supplied variable. 
strtok() uses static storage, which is not safe in a multithreaded kernel like Pintos.

>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.
1. The kernel focus only on executing binaries, keeping it smaller and more secure
2. The shell supports features like piping, redirection, and scripting, which require 
more complex parsing than the kernel should manage.


// Above is for Project 2-1

                 SYSTEM CALLS
                 ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

in /thread.h/..

struct thread
{
...
#ifdef USERPROG (this means below is executed if thread is user thread)
    /* Owned by userprog/process.c. */
    uint32_t *pagedir;                  /* Page directory. */
    int exit_status;   // newly added  /  stores exit status for exit call.
    struct file* fdt[128]; // newly added / thread stores fd_table for file I/O.

   // project 2-2 //

    struct list child_list; 
    struct list_elem child_elem;
    struct semaphore wait_sema;
    struct semaphore exit_sema;
    bool is_waited;

    bool load_success; //! load success
    struct semaphore load_sema; //! sema for load success

    struct file* running_file; //! current running_file for denial of writing.


#endif
...
}

exit status is member of user_thread for saving exit_status.
fdt[128] is fd_table for saving 128 file descriptors in user_thread.

// project 2-2

child_list is new list for child lists. if child is created, then child's elem is added to the child_list.
child_elem is element of thread used for child_list.
wait_sema & exit_sema are the semaphore.
wait_sema is semaphore for parent which is waiting child's exit.
exit_sema is semaphore for child which is waiting for parent's access of exit status.
-> then, child can terminate.

in /syscall.c

struct lock file_lock; // lock for file system.

file_lock can make two or more threads unable to access file system simultaneously.

in /process.c

extern struct lock file_lock; //! exatly same with file_lock in syscall.c


>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?

In PintOS, file descriptors (FDs) are stored in the fd_table, which is a member of the user_thread structure.
Each process (user thread) has its own fd_table, so file descriptors are unique within a process, not across the entire OS.
When a file is opened, the system assigns the lowest available FD number in the table, so file descriptor maybe not unique.
However, only standard input (stdin) and standard output (stdout) can have unique fd in PintOS,
since by default, file descriptor 0 is reserved for stdin and file descriptor 1 for stdout.
(Unlike in full UNIX systems, standard error (stderr, fd 2) is not predefined in PintOS.)

---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.

1) read

if fd == 0, then input_getc is used to read the character from keyboard.
then, return the number of characters get from input_getc().

Consider 2<=fd<64.

First, check whether file is NULL or not. if NULL, then call exit.
if not, then read the file using file_read function in filesys.c.
then, return the return value of file_read.

2) write

if fd == 1, then write the contents in buffer to console, using putbuf().
then, return the size of contents that was written in console.

Consider 2<=fd<64.

First, check whether file is NULL or not. if NULL, then call exit.
if not, then write the file using file_write function in filesys.c.
then, return the return value of file_write.

* In both cases, the file_lock is applied for access of file system. *

>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?

For full page (4096 bytes), least = 1, max = 4096.
For 1, there could be case that all data is in the same page. (Not exceeding page boundary)
For 4096, there could be the case that all data is in different page, so 4096 page inspectation is needed.

For 2 bytes,  least = 1, max = 2.
For 1, same as full page, all data is in same page, so 1 page inspectation is needed.
For 2, there could be case that 2 byte of data is in different pages. 

For improvements :  instead of call pagedir_get_page() for every bit, call pagedir_get_page() only when page is changed. In this case, although possible maximum calls of pagedir_get_page() can be same, but in ordinary, pagedir_get_page() is called fewer times.


>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

For project 2-1, we implemented process_wait function as

int process_wait(tid_t child_tid UNUSED)
{
    timer_msleep (3000); //! for debugging
    return -1;
}

This function was used to artificially delay the parent process, allowing the child process enough time to execute and terminate.
Without this delay, the parent process would return immediately, which may cause the child process to be terminated before it has a chance to run properly.

However, this is not a correct implementation of process_wait, since it simply waits for a fixed duration regardless of whether the child has actually exited.
Therefore, this placeholder implementation must be replaced in Project 2-2 with a proper mechanism that waits for a specific child process to exit and returns its exit status. 
This is essential for the correct behavior of fork, exec, and related process control operations.

// Project 2-2

In Project 2-2, wait in syscall.c is not different from project2-1, just calling process_wait(pid);.
But, process_wait in process.c is different. 
By adding bool is_waited / sema wait_sema / sema exit_sema / child_list / child_elem, 
process can wait until child process terminates.

First, check whether there is child process having child pid, by using struct thread* get_child().
get_child returns child process's thread having same pid given as argument.
At the same time, check whether if there is another parent process waiting that child process.
if two conditions are not met, then return -1.

If met, make child->is_waited to true, indicating there is parent process that is waiting child.
And, down the child's wait_sema, resulting parent process to wait until child to exit.
(in process_exit, wait_sema is released, and exit_sema is downed.)
After, parent process get exit status of child, remove the child thread's element in child_list, and release the exit_sema, allowing child thread to terminate.

>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.


---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

               SURVEY QUESTIONS
               ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?


==== Peer Evaluation ====

+----------------------------+---------------------------------+

|            Name            |          Contribution           |

+----------------------------+---------------------------------+

| 김동욱                      | 50%, Main contribution on wait, exit (semaphore). Debugging entire project.

+----------------------------+---------------------------------+

| 이강준                      | 50%, Main contribution on System_call, file_lock, Denying write to Executables. Debugging entire project.

+----------------------------+---------------------------------+
